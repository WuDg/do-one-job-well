# 核心技术

[文档地址](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html)

这部分参考文档覆盖了`Spring`框架绝对不可或缺的所有技术。

其中最重要的就是`Spring`框架的控制反转(IoC Inversion of Control)容器。之后就是面向切面编程（AOP Aspect-Oriented Programming）技术。`Spring`框架拥有自己的`AOP`框架，它在概念上更容易理解，并且成功解决了`Java`企业编程中 `80%` 的`AOP`需求。

`Spring`还提供了和`AspectJ`（目前Java企业领域中最成熟的`AOP`实现）集成的内容



## 1. IoC 容器

### 1.1. 介绍 Spring IoC 容器和 Beans

本章介绍了Spring框架中控制反转原理的实现。

Ioc 也被成为依赖注入（DI dependency injection），是一个对象定义其依赖（一同工作的其他对象）关系的过程。只有通过构造函数参数、工厂方法参数或者对象实例被构造或从工厂方法返回后设置的属性。

然后容器在创建bean时注入这些依赖项，这个过程从根本上说是bean创建的逆过程，因此被称为控制反转。

`org.springframework.beans` 和 `org.springframework.context` 包是`Spring`框架`IoC`容器的基础。

`BeanFactory`接口提供了能够管理任何类型对象的高级配置机制。`ApplicationContext`是`BeanFactory`的子接口。增加了以下功能

* 更容易整合`Spring`的`AOP`特性
* 消息资源处理（对于使用国际化）
* 事件发布
* 应用层特殊上下文，如`web`应用的 `WebApplicationContext`

总的来说，`BeanFactory`提供了配置框架和基础功能，而`ApplicationContext`添加了更多特定于企业的功能

在`Spring`中，构成应用程序主干并由`Spring IoC`容器管理的对象称为`bean`。

`bean`是由`Spring IoC`容器`实例化、组装和管理`的对象。`bean`及其依赖关系反映在容器使用的`配置元数据`中

## 1.2. 容器概览

`ApplicationContext`接口代表`Spring IoC`容器和它负责实例化、配置和组装的bean。容器通过读取配置元数据获取关于要实例化、配置和组装哪些对象的指令。配置元数据用`XML、Java注解或Java代码`表示，它允许表示组成应用程序的对象以及这些对象之间丰富的相互依赖关系。

`Spring`提供了`ApplicationContext`接口的几个实现。在独立应用程序中，通常创建 `ClassPathXmlApplicationContext`或`FileSystemXmlApplicationContext`的实例。

![container magic](https://docs.spring.io/spring-framework/docs/current/reference/html/images/container-magic.png)

图1 `Spring IoC`容器

### 1.2.1. 配置元数据

作为应用程序开发人员，告诉`Spring`容器实例化、配置和组装应用程序中的对象

配置元数据通常以简单直观的XML格式提供

其他形式的配置元数据

* [基于注解配置](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-annotation-config) `Spring2.5`引入了对基于注解的配置元数据的支持
* [基于Java代码配置](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java) `Spring3.0`开始，Spring `JavaConfig`项目提供的许多特性都成为了`Spring`核心框架的一部分。`@Configuration,@Bean,@Import,@DependsOn`注解

`Spring`配置的`IoC`容器管理至少一个`bean`

* 基于XML的配置元数据将bean配置为顶级<beans></beans>中的<bean></bean>元素

* 基于Java配置的通常在`@Configuration`类中使用`@Bean`注解



下面例子中展示基于`XML`配置元数据的基本结构

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="..." class="...">  
        <!-- 这个bean的协作者和配置在此 -->
        <!-- id：表示单个bean定义的字符串，class：定义bean的类型，使用类完全限定类名 -->
    </bean>

    <bean id="..." class="...">
    </bean>

</beans>
```

### 1.2.2 初始化容器

`ApplicationContext`构造函数指定资源路径（本地文件系统、`Java`类路径等）来加载配置元数据

`services.xml` 和 `daos.xml` 都是`resources`目录下的配置文件

```java
ApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");
```

下面的示例显示了服务层对象（`services.xml`）的配置文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- services -->

    <bean id="petStore" class="com.wdg.spring.service.impl.PetStoreServiceImpl">
        <property name="accountDao" ref="accountDao"/>
        <property name="itemDao" ref="itemDao"/>
    </bean>

</beans>
```

下面的示例显示了数据访问对象（`daos.xml`）文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="accountDao"
        class="com.wdg.spring.dao.AccountDao">
    </bean>

    <bean id="itemDao" class="com.wdg.spring.dao.ItemDao">
    </bean>

</beans>
```

**组合基于xml配置元数据**

```xml
<beans>
    <import resource="daos.xml"/>
    <import resource="services.xml"/>
    <bean id="bean1" class="com.wdg.spring.bean.Bean1"></bean>
    <bean id="bean2" class="com.wdg.spring.bean.Bean2"></bean>

</beans>
```

### 1.2.3. 使用容器

`ApplicationContext`允许读取bean定义并访问它们

```java
public class LoadBeanConfig {
    private static final Gson GSON = new Gson();
    private static final Logger logger = Logger.getLogger(LoadBeanConfig.class);
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");
        PetStoreServiceImpl petStore = context.getBean("petStore", PetStoreServiceImpl.class);
        List<String> usernameList = petStore.getUsernameList();

        logger.info(GSON.toJson(usernameList));
        logger.info(GSON.toJson(petStore));
    }
}
```

## 1.3. Bean概览

`Spring IoC`容器管理一个或多个`bean`。这些bean是使用提供给容器的配置元数据创建的（如`XML`定义的<bean/>形式）

在容器内部，这些`bean`定义表示为`BeanDefinition`对象，其中包含以下元数据

* 包限定类名：通常是被定义的`bean`的实际实现类
* `Bean`行为配置元素，它声明Bean在容器中的行为（作用域、声明周期回调等）
* 对其他`bean`的引用是该`bean`完成其工作所需要的。这些引用也被成为协作者或依赖
* 管理连接池的`bean`中使用连接数量

表1 bean定义

| 属性         | 解释           |
| ------------ | -------------- |
| Class        | 实例化Bean     |
| Name         | 命名Bean       |
| Scope        | Bean作用域     |
| 构造参数     | 依赖注入       |
| Properties   | 依赖注入       |
| 自动注入模式 | 自动注入合作者 |
| 懒加载模式   | 懒加载Bean     |
| 初始化方法   | bean实例化回调 |
| 销毁方法     | bean销毁回调   |

### 1.3.1. Bean命名

每个`bean`都有一个或多个标识符。这些标识符必须是唯一的，一个`bean`通常只有一个标识符，如果要求有多个标识符，则其它的可以看做是别名

如果没有指定`id`和`name`属性，则`Spring`会给`bean`自动生成唯一的名字

**bean定义之外对bean设定别名**

```xml
<alias name="fromName" alias="toName"/>
```

### 1.3.2. 实例化bean

* 通过反射调用构造函数直接创建`bean`
* 容器调用类的静态工厂方法来创建`bean`

**内部类名字**

`com.example.SomeThing$OtherThing`

**构造函数实例化**

只需要有个空构造函数

```xml
<bean id="bean1" class="com.wdg.spring.bean.Bean1"/>

<bean name="bean2" class="com.wdg.spring.bean.Bean2"/>
```

**静态工厂方法实例化**

在遗留代码中调用静态工厂

```xml
<bean id="clientService"
    class="com.wdg.spring.bean.ClientService"
    factory-method="createInstance"/>
```

```java
public class ClientService {

    private static ClientService clientService = new ClientService("吴第广");
    private String name;
    private ClientService(String name){
        this.name = name;
    }
    private static ClientService createInstance(){
        return clientService;
    }
}
```

**实例工厂方法实例化**

```xml
<!-- the factory bean, which contains a method called createInstance() -->
<bean id="serviceLocator" class="com.wdg.spring.bean.DefaultServiceLocator">
    <!-- inject any dependencies required by this locator bean -->
</bean>

<!-- the bean to be created via the factory bean -->
<bean id="clientService1"
      factory-bean="serviceLocator"
      factory-method="createClientServiceInstance"/>
```

```java
public class DefaultServiceLocator {
    private static ClientService clientService = new ClientService("云云");

    public ClientService createClientServiceInstance() {
        return clientService;
    }
}
```

**确定bean的运行时类型**

```java
BeanFactory.getBean()
```

## 1.4. 依赖

多对象共同协作实现目标

### 1.4.1. 依赖注入

依赖注入（DI Dependency injection），就是对象通过构造函数参数，工厂方法参数，`setter`属性定义其依赖项的过程。

依赖注入有两种主要的变体：基于构造函数的依赖注入和基于`setter`的依赖注入

**基于构造的依赖注入**

基于构造函数的依赖注入是由容器调用带有多个参数的构造函数来完成的，每个参数代表一个依赖项。和调用带有特定参数的静态工厂方法来构造`bean`几乎是等价的

```java
public class SimpleMovieLister {

    // the SimpleMovieLister has a dependency on a MovieFinder
    private MovieFinder movieFinder;

    // a constructor so that the Spring container can inject a MovieFinder
    public SimpleMovieLister(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // business logic that actually uses the injected MovieFinder is omitted...
}
```

**构造函数参数解析**

* 类类型匹配

  ```xml
  <bean id="beanOne" class="com.wdg.spring.bean.ThingOne">
      <constructor-arg ref="beanThree"/>
      <constructor-arg ref="beanTwo"/>
  </bean>
  
  <bean id="beanTwo" class="com.wdg.spring.bean.ThingTwo"/>
  
  <bean id="beanThree" class="com.wdg.spring.bean.ThingThree"/>
  ```

* 基本类型匹配

  ```xml
  <bean id="exampleBean" class="com.wdg.spring.bean.ExampleBean">
      <constructor-arg type="int" value="7500000"/>
      <constructor-arg type="java.lang.String" value="42"/>
  </bean>
  ```

* 索引下标匹配（从0开始）

  ```xml
  <bean id="exampleBean" class="com.wdg.spring.bean.ExampleBean">
      <constructor-arg index="0" value="7500000"/>
      <constructor-arg index="1" value="42"/>
   </bean>
  ```

解决多个简单值得模糊性还可以解决构造函数有两个以上相同类型参数的模糊性

**构造参数名字**

使用`@ConstructorProperties`指定名字

```xml
<bean id="exampleBean2" class="com.wdg.spring.bean.ExampleBean">
    <constructor-arg name="years" value="7500000"/>
    <constructor-arg name="ultimateAnswer" value="42"/>
</bean>
```

```java
@ConstructorProperties({"years", "ultimateAnswer"})
public ExampleBean(int years, String ultimateAnswer) {
    this.years = years;
    this.ultimateAnswer = ultimateAnswer;
}
```

**基于`setter`依赖注入**

调用无参构造函数或无参数静态工厂方法实例化之后，通过调用`bean`的`setter`方法来实现

```java
public class SimpleMovieLister {

    // the SimpleMovieLister has a dependency on the MovieFinder
    private MovieFinder movieFinder;

    // a setter method so that the Spring container can inject a MovieFinder
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // business logic that actually uses the injected MovieFinder is omitted...
}
```

对于强制依赖使用构造函数，对于可选依赖使用setter方法或配置方法是一个很好的经验法则。

**依赖解析过程**

* 通过配置元数据中描述的bean来创建 `ApplicationContext`，配置元数据可以使用`XML，Java代码，或注解`
* 在创建`bean`时提供依赖项
* 每个`bean`的构造函数参数和`setter`都是有实际定义的或者引用的其他类
* `Spring`可以将字符串格式提供的值转换为所有内置类型，如`int、long、string、boolean`等

`循环依赖`

**依赖注入示例**

* 构造参数
* setter参数
* 静态工厂方法参数

2021年1月13日16:18:51